import numpy as np
import numpy.linalg as LA
import matplotlib.pyplot as plt

# --- utilitários simples --- #
def von_neumann_entropy(rho):
    rho = (rho + rho.conj().T) / 2
    vals = LA.eigvalsh(rho)
    vals = np.clip(np.real(vals), 0, 1)
    nz = vals[vals > 1e-12]
    return -np.sum(nz * np.log2(nz))

def partial_trace_A(rho):
    return np.trace(rho.reshape(2,2,2,2), axis1=1, axis2=3)

def partial_trace_B(rho):
    return np.trace(rho.reshape(2,2,2,2), axis1=0, axis2=2)

# --- estado de Werner --- #
def werner_state(p):
    bell = np.array([[0.5, 0,   0, 0.5],
                     [0,   0,   0, 0  ],
                     [0,   0,   0, 0  ],
                     [0.5, 0,   0, 0.5]])
    I4 = np.eye(4) / 4.0
    return p * bell + (1 - p) * I4

# --- correlações --- #
def mutual_information(rho):
    SA = von_neumann_entropy(partial_trace_A(rho))
    SB = von_neumann_entropy(partial_trace_B(rho))
    SAB = von_neumann_entropy(rho)
    return SA + SB - SAB

def classical_correlation_simple_Z(rho):
    P0 = np.array([[1,0],[0,0]])
    P1 = np.array([[0,0],[0,1]])
    M0 = np.kron(np.eye(2), P0)
    M1 = np.kron(np.eye(2), P1)

    cond_entropy = 0.0
    for M in (M0, M1):
        prob = np.real_if_close(np.trace(M @ rho))
        if prob > 1e-12:
            post = M @ rho @ M
            rhoA_cond = partial_trace_A(post) / prob
            cond_entropy += prob * von_neumann_entropy(rhoA_cond)

    SA = von_neumann_entropy(partial_trace_A(rho))
    return SA - cond_entropy

# --- gerar dados --- #
ps = np.linspace(0, 1, 100)
Is, Cs, Qs = [], [], []

for p in ps:
    rho = werner_state(p)
    I = mutual_information(rho)
    C = classical_correlation_simple_Z(rho)
    Q = I - C
    Is.append(I)
    Cs.append(C)
    Qs.append(Q)

# --- plotar --- #
plt.figure(figsize=(7,5))
plt.plot(ps, Is, label="Informação Mútua (I)", linewidth=2)
plt.plot(ps, Cs, label="Correlação Clássica (C, base Z)", linewidth=2)
plt.plot(ps, Qs, label="Discord Aproximada (Q=I-C)", linewidth=2, linestyle="--")

plt.xlabel("p (parâmetro do estado de Werner)")
plt.ylabel("Correlação (bits)")
plt.title("Decomposição I = C + Q (aproximada)")
plt.legend()
plt.grid(True)
plt.show()
