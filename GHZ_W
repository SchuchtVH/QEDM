import numpy as np

def partial_trace(rho, keep, dims):
    """Traço parcial: mantém apenas os subsistemas especificados em 'keep'."""
    n = len(dims)
    for i in reversed(range(n)):
        if i not in keep:
            dim = dims[i]
            rho = rho.reshape([int(rho.shape[0]/dim), dim,
                               int(rho.shape[1]/dim), dim])
            rho = np.trace(rho, axis1=1, axis2=3)
    return rho

def von_neumann_entropy(rho):
    """Entropia de von Neumann (bits)."""
    evals = np.real(np.linalg.eigvals(rho))
    evals = evals[evals > 1e-12]
    evals = evals / np.sum(evals)
    return -np.sum(evals * np.log2(evals))

def concurrence(rho):
    """Concorrência para dois qubits."""
    sigma_y = np.array([[0, -1j], [1j, 0]])
    Y = np.kron(sigma_y, sigma_y)
    rho_tilde = Y @ rho.conj() @ Y
    R = rho @ rho_tilde
    evals = np.sort(np.sqrt(np.maximum(np.real(np.linalg.eigvals(R)), 0)))
    return max(0, evals[-1] - np.sum(evals[:-1]))

def EOF_two_qubits(rho):
    """Emaranhamento de Formação (EOF) de dois qubits."""
    C = concurrence(rho)
    if C <= 0:
        return 0
    term1 = (1 + np.sqrt(1 - C**2)) / 2
    term2 = (1 - np.sqrt(1 - C**2)) / 2
    return -term1*np.log2(term1) - term2*np.log2(term2)

# -------------------- Estados GHZ e W --------------------
zero = np.array([1, 0])
one = np.array([0, 1])

ghz = (np.kron(np.kron(zero, zero), zero) + np.kron(np.kron(one, one), one)) / np.sqrt(2)
w = (np.kron(np.kron(zero, zero), one) +
     np.kron(np.kron(zero, one), zero) +
     np.kron(np.kron(one, zero), zero)) / np.sqrt(3)

rho_ghz = np.outer(ghz, ghz.conj())
rho_w = np.outer(w, w.conj())

dims = [2, 2, 2]

# -------------------- Função auxiliar: τ₃ --------------------
def residual_tangle(rho, dims, qubit=0):
    """Calcula o residual tangle (τ₃) e as concorrências individuais."""
    rhoA = partial_trace(rho, [qubit], dims)
    rhoAB = partial_trace(rho, [qubit, (qubit+1)%3], dims)
    rhoAC = partial_trace(rho, [qubit, (qubit+2)%3], dims)

    # concorrências
    C_A_BC = np.sqrt(2 * (1 - np.trace(rhoA @ rhoA)))  # para estado puro
    C_AB = concurrence(rhoAB)
    C_AC = concurrence(rhoAC)

    tau3 = C_A_BC**2 - (C_AB**2 + C_AC**2)
    return max(0, tau3), C_A_BC, C_AB, C_AC

# -------------------- Cálculos GHZ --------------------
EOF_A_BC_ghz = von_neumann_entropy(partial_trace(rho_ghz, [0], dims))
rhoAB_ghz = partial_trace(rho_ghz, [0, 1], dims)
rhoAC_ghz = partial_trace(rho_ghz, [0, 2], dims)
rhoBC_ghz = partial_trace(rho_ghz, [1, 2], dims)

EOF_AB_ghz = EOF_two_qubits(rhoAB_ghz)
EOF_AC_ghz = EOF_two_qubits(rhoAC_ghz)
EOF_BC_ghz = EOF_two_qubits(rhoBC_ghz)

tau3_ghz, C_A_BC_ghz, C_AB_ghz, C_AC_ghz = residual_tangle(rho_ghz, dims)

# -------------------- Cálculos W --------------------
EOF_A_BC_w = von_neumann_entropy(partial_trace(rho_w, [0], dims))
rhoAB_w = partial_trace(rho_w, [0, 1], dims)
rhoAC_w = partial_trace(rho_w, [0, 2], dims)
rhoBC_w = partial_trace(rho_w, [1, 2], dims)

EOF_AB_w = EOF_two_qubits(rhoAB_w)
EOF_AC_w = EOF_two_qubits(rhoAC_w)
EOF_BC_w = EOF_two_qubits(rhoBC_w)

tau3_w, C_A_BC_w, C_AB_w, C_AC_w = residual_tangle(rho_w, dims)

# -------------------- Resultados --------------------
print("===== Emaranhamento de Formação (EOF) e Concorrências =====\n")

print("Estado GHZ:")
print(f"  EOF(A:BC) = {EOF_A_BC_ghz:.4f} bits")
print(f"  EOF(A–B)  = {EOF_AB_ghz:.4f} bits")
print(f"  EOF(A–C)  = {EOF_AC_ghz:.4f} bits")
print(f"  EOF(B–C)  = {EOF_BC_ghz:.4f} bits")
print(f"  Concorrência C(A:BC) = {C_A_BC_ghz:.4f}")
print(f"  Concorrência C(A–B)  = {C_AB_ghz:.4f}")
print(f"  Concorrência C(A–C)  = {C_AC_ghz:.4f}")
print(f"  Residual tangle (τ₃) = {tau3_ghz:.4f}\n")

print("Estado W:")
print(f"  EOF(A:BC) = {EOF_A_BC_w:.4f} bits")
print(f"  EOF(A–B)  = {EOF_AB_w:.4f} bits")
print(f"  EOF(A–C)  = {EOF_AC_w:.4f} bits")
print(f"  EOF(B–C)  = {EOF_BC_w:.4f} bits")
print(f"  Concorrência C(A:BC) = {C_A_BC_w:.4f}")
print(f"  Concorrência C(A–B)  = {C_AB_w:.4f}")
print(f"  Concorrência C(A–C)  = {C_AC_w:.4f}")
print(f"  Residual tangle (τ₃) = {tau3_w:.4f}")
